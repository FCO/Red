#!env raku
use Red::Cli;
use Red::Do;
use Red::DB;
use Red::Database;
use Red::Configuration;

my %*SUB-MAIN-OPTS =
  :named-anywhere,
;

my $*RED-DEBUG;

proto MAIN(Str :$I, Bool :$debug,:$driver, IO() :$config = $*CWD.add("migration.rakuconfig"), |) {
    dyn-lib .split: "," with $I;
    my $*config = single-config-run :file($config);
    $*RED-DEBUG = $debug;
    {*}
}

#| Show model versions
multi MAIN(
    "migration",
    "model-versions",
    *%pars,
) {
    my UInt $size = $*config.models-cache.keys>>.chars.max;
    say "Models:";
    for $*config.models-cache.kv -> Str() $model, IO() $path {
        printf "\t%{ -$size }s => %s\n", $model, $path.relative
    }
}

#| Update DB based on the model and create highlevel objects about those changes
multi MAIN(
    "migration",
    "update",
    :$driver!,
    :$models,
    :$requires = $models,
    *%pars,
) {
    red-defaults $driver, |%pars with $driver;
    my $path = $*config.new-dump-version-path;
    $path.parent.mkdir;
    note "dump DB into { $path.relative }";
    get-RED-DB.dump: $path.relative;

    note "calculate the differences between the DB";
    my @reqs = $requires.comb(/<-[,]>+/);
    require ::($requires); # FIXME: loop over @reqs

    my @asts;

    for get-RED-DB.diff-to-ast: ::($models).^diff-from-db<> -> @data {
        @asts.append: @data;
    }
    note "The models and create high level changes file on { $*config.migration-red-path.relative }";
    # TODO: create high level way
    note "apply changes file on { $*config.migration-red-path.relative } on local DB";
    get-RED-DB.execute: $_ for @asts;
}

#| Redo transformation based on highlevel object (that could have been changed)
multi MAIN(
    "migration",
    "redo-update"
) {
    note "restore dump from { $*config.dump-version-path.relative }";
    note "exec highlevel changes from { $*config.migration-red-path.relative }"
}

#| Revert to the state before the last update
multi MAIN(
    "migration",
    "revert-update"
) {
    note "restore dump from { $*config.dump-version-path.relative }";
    note "delete dump from { $*config.dump-version-path.relative }";
    note "delete high level changes files from { $*config.migration-red-path.relative }";
    note "delete models from { $*config.model-storage-path.relative }"
}

#| Create (SQL) migration based on current a previous model version compared to last applied model
multi MAIN(
    "migration",
    "prepare",
    :$driver!,
    :$models,
    :$requires = $models,
    :$from-model-version!,
    *%pars,
) {...}

#| Create (SQL) migration based on current DB state compared to last applied model
multi MAIN(
    "migration",
    "prepare",
    :$driver!,
    :$models,
    :$requires = $models,
    *%pars,
) {
    red-defaults $driver, |%pars with $driver;
    note "create SQL to transform the last version of model into current state of the DB on { $*config.drivers.map({ $*config.migration-sql-path($_).relative }).join: " and " }";

    # Find current model version
    
    {
        use MONKEY-SEE-NO-EVAL;
        EVAL qq[use lib "{ $*config.model-storage-path.relative }";];

        my $path = $*config.model-path: $models;
        say $path;

        with $path {
            my $name = .extension("").basename;
            require ::($name);

            say ::($models).^ver;

            say ::($models).^diff-to-db;
            #
            # for get-RED-DB.diff-to-ast: ::($models).^diff-to-db<> -> @data {
            #     say @data;
            # }
        }
    }

    require ::($requires); # FIXME: loop over @reqs
    note "copy changed models files to new dir inside { $*config.model-storage-path.relative }";
    my $orig-path = ::($models).^methods(:local).head.file.split(/\s/).head;
    $*config.copy-model: $orig-path;
    # note "Model copied to { $new-path.relative }"

    note "delete all dumps on { $*config.dump-storage-path.relative }";
}

#| Apply SQL (possibly changed) into prod DB
multi MAIN(
    "migration",
    "apply",
    Str :$driver
) {
    die "Driver does not exist on configuration (options: { $*config.drivers.join: ", " })" unless $driver ~~ $*config.drivers.any;
    note "apply SQL from { $*config.migration-sql-path($driver).relative }";
}

# #| List tables in database
# multi MAIN(
#     "list-tables",
#     Str  :$driver!,
#     *%pars
# ) {
#     my $*RED-DB = database($driver, |%pars);
#     .say for list-tables :$driver, |%pars
# }
#
# #| Generate stub code to access models from database schema
# multi MAIN(
#     "print-stub",
#     Str  :$schema-class,
#     Str  :$driver!,
#     *%pars
# ) {
#     my $*RED-DB = database($driver, |%pars);
#     say gen-stub-code :$schema-class, :$driver, |%pars
# }
#
#
# #| Generates migration plan to upgrade database schema
# multi MAIN(
#     "migration-plan",
#     Str :$model!,
#     Str :$require = $model,
#     Str :$driver!,
#     *%pars
# ) {
#     my $*RED-DB = database($driver, |%pars);
#     migration-plan :$model, :$require, :$driver, |%pars
# }
#
# #| Generates models' code from database schema
# multi MAIN(
#     "generate-code",
#     Str  :$path!    where { not .defined or .IO.d or $_ eq "-" or fail "Path $_ does not exist." },
#     Str  :$from-sql where { not .defined or .IO.f or $_ eq "-" or fail "SQL $_ do not exist." },
#     Str  :$schema-class,
#     Bool :$print-stub       = False,
#     Bool :$no-relationships = False,
#     #Bool :$stub-only,
#     Str  :$driver!,
#     *%pars
# ) {
#     my $*RED-DB = database($driver, |%pars);
#     generate-code
#             :$path,
#             :$from-sql,
#             :$schema-class,
#             :$print-stub,
#             :$no-relationships,
#             :$driver,
#             |%pars
# }
#
# #| Prepare database
# multi MAIN(
#         "prepare-database",
#         Bool :$populate,
#         Str  :$models!,
#         Str  :$driver!,
#         *%pars
# ) {
#     $GLOBAL::RED-DB = database $driver, |%pars;
#     prepare-database :$populate, :$models, :$driver, |%pars
# }

sub dyn-lib(@libs) {
	qq[use lib "{ $_ }"].EVAL for @libs
}
