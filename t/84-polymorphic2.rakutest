use v6;
use Test;
use Red;

use lib $?FILE.IO.parent(1).add('lib');

my $*RED-DEBUG          = $_ with %*ENV<RED_DEBUG>;
my $*RED-DEBUG-RESPONSE = $_ with %*ENV<RED_DEBUG_RESPONSE>;
my @conf                = (%*ENV<RED_DATABASE> // "SQLite").split(" ");
my $driver              = @conf.shift;
my $*RED-DB             = database $driver, |%( @conf.map: { do given .split: "=" { .[0] => val .[1] } } );

model Buyer  { ... }
model Seller { ... }

model Login is table<logged_user> {
    has         $.id        is serial;
    has         $.source    is column;
    has UInt    $.source-id is referencing(*.id, :model<Buyer>);
    has Instant $.created   is column = now;
    has Buyer   $.buyer     is relationship{ $^b.id == $^a.source-id && $^a.source eq "buyer"  }
    has Seller  $.seller    is relationship{ $^b.id == $^a.source-id && $^a.source eq "seller" }
}

model Buyer {
    has UInt  $.id     is serial;
    has Str   $.name   is column;
    has Login @.logins is relationship{ $^a.id == $^b.source-id && $^b.source eq "buyer" }
}

model Seller {
    has UInt  $.id     is serial;
    has Str   $.name   is column;
    has Login @.logins is relationship{ $^a.id == $^b.source-id && $^b.source eq "seller" }
}

red-defaults "SQLite";
schema(Buyer, Seller, Login).create;

my $comprador = Buyer.^create:  :name<Comprador>;
my $vendedor  = Seller.^create: :name<Vendedor>;

$comprador.logins.create;
$vendedor.logins.create;

is $comprador.logins.map(*.id), <1>;
is $vendedor.logins .map(*.id), <2>;

is
    Login.^all.Seq.map({
        "Login: { .id }; Buyer: { .name with .buyer }; Seller: { .name with .seller }"
    }).join("\n"),
    chomp q:to/END/;
Login: 1; Buyer: Comprador; Seller: 
Login: 2; Buyer: ; Seller: Vendedor
END

done-testing
